name: Android Build and Deploy

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
  workflow_dispatch:

env:
  JAVA_VERSION: '17'

jobs:
  build:
    name: Build, Sign & Deploy Android APKs
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew

      - name: Accept Android SDK licenses
        run: |
          # Accept licenses in global Android SDK
          yes | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager --licenses || true
          
          # Create local SDK licenses directory and copy accepted licenses
          mkdir -p android/licenses
          cp -r $ANDROID_HOME/licenses/* android/licenses/ || true
          
          echo "âœ… Android SDK licenses accepted and copied to project"

      - name: Decode and prepare keystore
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          echo "ðŸ” Decoding keystore from GitHub Secrets..."
          echo "$ANDROID_KEYSTORE_BASE64" | base64 --decode > ${{ github.workspace }}/release.keystore
          ls -lh ${{ github.workspace }}/release.keystore
          echo "âœ… Keystore prepared successfully"

      - name: Set versioning metadata
        id: version
        run: |
          # Calculate version code from GitHub run number
          VERSION_CODE=$((GITHUB_RUN_NUMBER + 100))
          
          # Determine version name based on tag or commit
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION_NAME="${GITHUB_REF#refs/tags/}"
          else
            COMMIT_SHORT="${GITHUB_SHA:0:7}"
            VERSION_NAME="1.0.${VERSION_CODE}-${COMMIT_SHORT}"
          fi
          
          echo "version_code=${VERSION_CODE}" >> $GITHUB_OUTPUT
          echo "version_name=${VERSION_NAME}" >> $GITHUB_OUTPUT
          echo "commit_short=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Version Code: ${VERSION_CODE}"
          echo "ðŸ“¦ Version Name: ${VERSION_NAME}"
          echo "ðŸ“¦ Commit: ${GITHUB_SHA:0:7}"

      - name: Build Debug APK
        working-directory: android
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_SHA: ${{ github.sha }}
          KEYSTORE_FILE: ${{ github.workspace }}/release.keystore
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_ALIAS_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building debug APK with release signing..."
          ./gradlew assembleDebug --no-daemon --stacktrace
          
          # Find the built APK
          DEBUG_APK=$(find app/build/outputs/apk/debug -name "*.apk" | head -1)
          echo "DEBUG_APK_PATH=${DEBUG_APK}" >> $GITHUB_ENV
          
          if [ -f "$DEBUG_APK" ]; then
            ls -lh "$DEBUG_APK"
            echo "âœ… Debug APK built successfully: $DEBUG_APK"
          else
            echo "âŒ Debug APK not found!"
            exit 1
          fi

      - name: Build Release APK and AAB
        working-directory: android
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_SHA: ${{ github.sha }}
          KEYSTORE_FILE: ${{ github.workspace }}/release.keystore
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_ALIAS_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building release APK and AAB..."
          ./gradlew assembleRelease bundleRelease --no-daemon --stacktrace
          
          # Find the built artifacts
          RELEASE_APK=$(find app/build/outputs/apk/release -name "*.apk" | head -1)
          RELEASE_AAB=$(find app/build/outputs/bundle/release -name "*.aab" | head -1)
          
          echo "RELEASE_APK_PATH=${RELEASE_APK}" >> $GITHUB_ENV
          echo "RELEASE_AAB_PATH=${RELEASE_AAB}" >> $GITHUB_ENV
          
          if [ -f "$RELEASE_APK" ]; then
            ls -lh "$RELEASE_APK"
            echo "âœ… Release APK built successfully: $RELEASE_APK"
          else
            echo "âŒ Release APK not found!"
            exit 1
          fi
          
          if [ -f "$RELEASE_AAB" ]; then
            ls -lh "$RELEASE_AAB"
            echo "âœ… Release AAB built successfully: $RELEASE_AAB"
          else
            echo "âš ï¸ Release AAB not found (optional)"
          fi

      - name: Verify APK signatures
        working-directory: android
        run: |
          echo "ðŸ” Verifying APK signatures with apksigner..."
          
          # Install build tools if needed
          sdkmanager "build-tools;34.0.0" > /dev/null 2>&1 || true
          APKSIGNER="${ANDROID_HOME}/build-tools/34.0.0/apksigner"
          
          # Verify debug APK
          echo "Verifying debug APK..."
          $APKSIGNER verify --verbose "$DEBUG_APK_PATH" > debug_verify.txt 2>&1
          cat debug_verify.txt
          
          if grep -q "Verifies" debug_verify.txt; then
            echo "âœ… Debug APK signature verified"
          else
            echo "âŒ Debug APK signature verification failed!"
            exit 1
          fi
          
          # Verify release APK
          echo "Verifying release APK..."
          $APKSIGNER verify --verbose "$RELEASE_APK_PATH" > release_verify.txt 2>&1
          cat release_verify.txt
          
          if grep -q "Verifies" release_verify.txt; then
            echo "âœ… Release APK signature verified"
          else
            echo "âŒ Release APK signature verification failed!"
            exit 1
          fi

      - name: Extract APK metadata
        id: apk_metadata
        run: |
          # Extract metadata from RELEASE APK using aapt
          APK_PATH="android/$RELEASE_APK_PATH"
          
          # Get file size
          FILE_SIZE=$(stat -c%s "$APK_PATH")
          echo "FILE_SIZE=$FILE_SIZE" >> $GITHUB_OUTPUT
          
          # Calculate SHA256
          SHA256=$(sha256sum "$APK_PATH" | awk '{print $1}')
          echo "SHA256=$SHA256" >> $GITHUB_OUTPUT
          
          # Get signer fingerprint
          SIGNER_FP=$(keytool -printcert -jarfile "$APK_PATH" 2>/dev/null | grep "SHA256:" | head -1 | awk '{print $2}' || echo "RELEASE_KEY")
          echo "SIGNER_FINGERPRINT=$SIGNER_FP" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š Metadata extracted:"
          echo "  File size: $FILE_SIZE bytes"
          echo "  SHA256: $SHA256"
          echo "  Signer: $SIGNER_FP"

      - name: Check backend connectivity
        env:
          BACKEND_URL_DEV: ${{ secrets.NEXMDM_BACKEND_URL_DEV }}
          BACKEND_URL_PROD: ${{ secrets.NEXMDM_BACKEND_URL_PROD }}
        run: |
          echo "ðŸ” Checking backend connectivity for both dev and prod..."
          
          # Function to check a single backend
          check_backend() {
            local BACKEND_URL=$1
            local ENV_NAME=$2
            
            echo ""
            echo "================================================"
            echo "Checking $ENV_NAME backend: $BACKEND_URL"
            echo "================================================"
            
            # Check if frontend is accessible (with retry for cold starts)
            echo "Testing frontend accessibility..."
            MAX_RETRIES=3
            RETRY_DELAY=10
            FRONTEND_CODE="000"
            
            for i in $(seq 1 $MAX_RETRIES); do
              FRONTEND_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$BACKEND_URL" || echo "000")
              
              if [ "$FRONTEND_CODE" = "000" ]; then
                echo "âŒ Attempt $i/$MAX_RETRIES: Cannot reach frontend at $BACKEND_URL"
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "   Retrying in ${RETRY_DELAY}s..."
                  sleep $RETRY_DELAY
                fi
              elif [ "$FRONTEND_CODE" = "502" ] || [ "$FRONTEND_CODE" = "503" ] || [ "$FRONTEND_CODE" = "504" ]; then
                echo "âš ï¸  Attempt $i/$MAX_RETRIES: Frontend returned HTTP $FRONTEND_CODE (app may be starting)"
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "   Retrying in ${RETRY_DELAY}s..."
                  sleep $RETRY_DELAY
                fi
              elif [ "$FRONTEND_CODE" = "200" ] || [ "$FRONTEND_CODE" = "301" ] || [ "$FRONTEND_CODE" = "302" ]; then
                echo "âœ… Frontend is accessible (HTTP $FRONTEND_CODE)"
                break
              else
                echo "âœ… Frontend responded (HTTP $FRONTEND_CODE)"
                break
              fi
            done
            
            # Check if backend health endpoint is accessible via proxy
            echo "Testing backend health via proxy..."
            HEALTH_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$BACKEND_URL/api/proxy/healthz" || echo "000")
            if [ "$HEALTH_CODE" = "000" ] || [ "$HEALTH_CODE" = "502" ] || [ "$HEALTH_CODE" = "504" ]; then
              echo "âš ï¸  WARNING: $ENV_NAME backend health check failed (HTTP $HEALTH_CODE)"
              echo "   The backend may still be starting up - will attempt upload anyway"
            elif [ "$HEALTH_CODE" = "200" ]; then
              echo "âœ… $ENV_NAME backend is healthy and accessible via proxy"
            else
              echo "âš ï¸  $ENV_NAME backend returned HTTP $HEALTH_CODE (may still be functional)"
            fi
            
            # Return status (0 = success, 1 = failure)
            if [ "$FRONTEND_CODE" = "000" ] || [ "$FRONTEND_CODE" = "502" ] || [ "$FRONTEND_CODE" = "503" ] || [ "$FRONTEND_CODE" = "504" ]; then
              return 1
            else
              return 0
            fi
          }
          
          # Check both backends
          # Status values: 0 = reachable, 1 = unreachable, 2 = not configured
          DEV_OK=2
          PROD_OK=2
          
          if [ -z "$BACKEND_URL_DEV" ]; then
            echo "âš ï¸  WARNING: NEXMDM_BACKEND_URL_DEV secret is not set!"
            DEV_OK=2  # Explicitly mark as not configured
          else
            check_backend "$BACKEND_URL_DEV" "DEV" || DEV_OK=1
          fi
          
          if [ -z "$BACKEND_URL_PROD" ]; then
            echo "âš ï¸  WARNING: NEXMDM_BACKEND_URL_PROD secret is not set!"
            PROD_OK=2  # Explicitly mark as not configured
          else
            check_backend "$BACKEND_URL_PROD" "PROD" || PROD_OK=1
          fi
          
          # Fail if both are unreachable (but not if both are just not configured)
          if [ "$DEV_OK" = "1" ] && [ "$PROD_OK" = "1" ]; then
            echo ""
            echo "âŒ ERROR: Both dev and prod backends are unreachable"
            echo "   Please ensure at least one backend is running"
            exit 1
          fi
          
          echo ""
          echo "âœ… Connectivity check complete"
          if [ "$DEV_OK" = "0" ]; then
            echo "   âœ… DEV backend is reachable"
          elif [ "$DEV_OK" = "2" ]; then
            echo "   âš ï¸  DEV backend is not configured (will skip upload)"
          else
            echo "   âš ï¸  DEV backend is not reachable (will skip upload)"
          fi
          if [ "$PROD_OK" = "0" ]; then
            echo "   âœ… PROD backend is reachable"
          elif [ "$PROD_OK" = "2" ]; then
            echo "   âš ï¸  PROD backend is not configured (will skip upload)"
          else
            echo "   âš ï¸  PROD backend is not reachable (will skip upload)"
          fi
      
      - name: Upload APK to NexMDM backends (Dev & Prod)
        env:
          BACKEND_URL_DEV: ${{ secrets.NEXMDM_BACKEND_URL_DEV }}
          BACKEND_URL_PROD: ${{ secrets.NEXMDM_BACKEND_URL_PROD }}
          ADMIN_KEY: ${{ secrets.NEXMDM_ADMIN_KEY }}
        run: |
          # Verify admin key is set
          if [ -z "$ADMIN_KEY" ]; then
            echo "âŒ ERROR: NEXMDM_ADMIN_KEY secret is not set!"
            exit 1
          fi
          
          BUILD_ID="gh_${{ github.run_id }}_${{ github.run_number }}"
          APK_PATH="android/${{ env.RELEASE_APK_PATH }}"
          
          echo "================================================"
          echo "ðŸš€ Uploading RELEASE APK to NexMDM backends"
          echo "================================================"
          echo "Build ID: $BUILD_ID"
          echo "Version: ${{ steps.version.outputs.version_name }} (code: ${{ steps.version.outputs.version_code }})"
          echo "File size: $(stat -c%s "$APK_PATH") bytes"
          echo "SHA256: ${{ steps.apk_metadata.outputs.SHA256 }}"
          echo "================================================"
          
          # Function to upload to a single backend
          upload_to_backend() {
            local BACKEND_URL=$1
            local ENV_NAME=$2
            local TMP_DIR="/tmp/upload_${ENV_NAME,,}"
            
            mkdir -p "$TMP_DIR"
            
            echo ""
            echo "================================================"
            echo "ðŸ“¤ Uploading to $ENV_NAME backend"
            echo "================================================"
            echo "Backend URL: $BACKEND_URL"
            echo "Upload URL: $BACKEND_URL/api/apk/upload"
            
            # Upload through Next.js API route which proxies to backend /admin/apk/upload
            # This creates the APK record and stores the file in one request
            # NOTE: We capture HTTP code to a separate file to avoid issues with HTTP 100 Continue
            curl -L --post301 --max-time 300 -v -X POST "$BACKEND_URL/api/apk/upload" \
              -H "X-Admin: $ADMIN_KEY" \
              -H "Expect:" \
              -F "file=@$APK_PATH" \
              -F "build_id=$BUILD_ID" \
              -F "version_code=${{ steps.version.outputs.version_code }}" \
              -F "version_name=${{ steps.version.outputs.version_name }}" \
              -F "build_type=release" \
              -F "package_name=com.nexmdm" \
              -w "%{http_code}" \
              -o "$TMP_DIR/response.txt" \
              2>"$TMP_DIR/verbose.txt" \
              > "$TMP_DIR/http_code.txt"
            
            # Read HTTP code from file (avoids issues with stdout/stderr mixing)
            HTTP_CODE=$(cat "$TMP_DIR/http_code.txt" 2>/dev/null | tr -d '[:space:]')
            UPLOAD_RESPONSE=$(cat "$TMP_DIR/response.txt" 2>/dev/null || echo "No response")
            
            # Show verbose output for debugging (last 30 lines)
            if [ -f "$TMP_DIR/verbose.txt" ]; then
              echo ""
              echo "ðŸ“‹ Verbose curl output (last 30 lines):"
              tail -n 30 "$TMP_DIR/verbose.txt"
            fi
            
            echo ""
            echo "ðŸ“¥ Upload response:"
            echo "HTTP Status: $HTTP_CODE"
            echo "Response: $UPLOAD_RESPONSE"
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
              echo ""
              echo "âœ… SUCCESS: Release APK registered and uploaded to $ENV_NAME backend!"
              echo "View build at: $BACKEND_URL/apk-management"
              echo "$ENV_NAME:SUCCESS:$BACKEND_URL" >> /tmp/upload_results.txt
              return 0
            else
              echo ""
              echo "âŒ FAILED: $ENV_NAME backend upload returned HTTP $HTTP_CODE"
              echo "Response: $UPLOAD_RESPONSE"
              echo "$ENV_NAME:FAILED:$BACKEND_URL:$HTTP_CODE" >> /tmp/upload_results.txt
              return 1
            fi
          }
          
          # Initialize results file
          echo "" > /tmp/upload_results.txt
          
          # Upload to both backends in parallel using background jobs
          DEV_PID=""
          PROD_PID=""
          
          if [ -n "$BACKEND_URL_DEV" ]; then
            echo ""
            echo "ðŸš€ Starting DEV backend upload in background..."
            (upload_to_backend "$BACKEND_URL_DEV" "DEV") &
            DEV_PID=$!
          else
            echo "âš ï¸  Skipping DEV backend upload (NEXMDM_BACKEND_URL_DEV not set)"
            echo "DEV:SKIPPED" >> /tmp/upload_results.txt
          fi
          
          if [ -n "$BACKEND_URL_PROD" ]; then
            echo ""
            echo "ðŸš€ Starting PROD backend upload in background..."
            (upload_to_backend "$BACKEND_URL_PROD" "PROD") &
            PROD_PID=$!
          else
            echo "âš ï¸  Skipping PROD backend upload (NEXMDM_BACKEND_URL_PROD not set)"
            echo "PROD:SKIPPED" >> /tmp/upload_results.txt
          fi
          
          # Wait for both uploads to complete
          DEV_EXIT=2  # Default to skipped (2 = skipped, 0 = success, 1 = failed)
          PROD_EXIT=2
          
          if [ -n "$DEV_PID" ]; then
            wait $DEV_PID
            DEV_EXIT=$?
          elif [ -z "$BACKEND_URL_DEV" ]; then
            DEV_EXIT=2  # Explicitly mark as skipped
          fi
          
          if [ -n "$PROD_PID" ]; then
            wait $PROD_PID
            PROD_EXIT=$?
          elif [ -z "$BACKEND_URL_PROD" ]; then
            PROD_EXIT=2  # Explicitly mark as skipped
          fi
          
          # Summary
          echo ""
          echo "================================================"
          echo "ðŸ“Š Upload Summary"
          echo "================================================"
          cat /tmp/upload_results.txt | while IFS=: read -r env status url code; do
            if [ "$status" = "SUCCESS" ]; then
              echo "âœ… $env: Upload successful â†’ $url/apk-management"
            elif [ "$status" = "FAILED" ]; then
              echo "âŒ $env: Upload failed (HTTP $code) â†’ $url"
            elif [ "$status" = "SKIPPED" ]; then
              echo "âš ï¸  $env: Upload skipped (secret not configured)"
            fi
          done
          echo "================================================"
          
          # Fail the step if both uploads failed (or if only one is configured and it failed)
          if [ -n "$BACKEND_URL_DEV" ] && [ -n "$BACKEND_URL_PROD" ]; then
            # Both configured - fail if both failed
            if [ "$DEV_EXIT" != "0" ] && [ "$PROD_EXIT" != "0" ]; then
              echo ""
              echo "âŒ ERROR: Both dev and prod uploads failed!"
              exit 1
            elif [ "$DEV_EXIT" != "0" ]; then
              echo ""
              echo "âš ï¸  WARNING: DEV upload failed, but PROD succeeded"
            elif [ "$PROD_EXIT" != "0" ]; then
              echo ""
              echo "âš ï¸  WARNING: PROD upload failed, but DEV succeeded"
            else
              echo ""
              echo "âœ… SUCCESS: Both dev and prod uploads completed successfully!"
            fi
          elif [ -n "$BACKEND_URL_DEV" ]; then
            # Only dev configured
            if [ "$DEV_EXIT" != "0" ]; then
              echo ""
              echo "âŒ ERROR: DEV upload failed!"
              exit 1
            fi
          elif [ -n "$BACKEND_URL_PROD" ]; then
            # Only prod configured
            if [ "$PROD_EXIT" != "0" ]; then
              echo ""
              echo "âŒ ERROR: PROD upload failed!"
              exit 1
            fi
          else
            echo ""
            echo "âŒ ERROR: No backend URLs configured!"
            echo "   Please set NEXMDM_BACKEND_URL_DEV and/or NEXMDM_BACKEND_URL_PROD"
            exit 1
          fi
          
          # Store results for build summary
          echo "DEV_EXIT=$DEV_EXIT" >> $GITHUB_ENV
          echo "PROD_EXIT=$PROD_EXIT" >> $GITHUB_ENV
      
      - name: Upload Release APK as artifact
        uses: actions/upload-artifact@v4
        with:
          name: nexmdm-release-apk-${{ steps.version.outputs.version_code }}
          path: android/${{ env.RELEASE_APK_PATH }}
          retention-days: 90

      - name: Upload Release AAB as artifact
        if: env.RELEASE_AAB_PATH != ''
        uses: actions/upload-artifact@v4
        with:
          name: nexmdm-release-aab-${{ steps.version.outputs.version_code }}
          path: android/${{ env.RELEASE_AAB_PATH }}
          retention-days: 90

      - name: Upload Debug APK as artifact
        uses: actions/upload-artifact@v4
        with:
          name: nexmdm-debug-apk-${{ steps.version.outputs.version_code }}
          path: android/${{ env.DEBUG_APK_PATH }}
          retention-days: 30

      - name: Generate build summary
        env:
          BACKEND_URL_DEV: ${{ secrets.NEXMDM_BACKEND_URL_DEV }}
          BACKEND_URL_PROD: ${{ secrets.NEXMDM_BACKEND_URL_PROD }}
          DEV_EXIT: ${{ env.DEV_EXIT }}
          PROD_EXIT: ${{ env.PROD_EXIT }}
        run: |
          # Determine deployment status
          DEV_STATUS=""
          PROD_STATUS=""
          
          if [ -n "$BACKEND_URL_DEV" ]; then
            if [ "${DEV_EXIT:-1}" = "0" ]; then
              DEV_STATUS="âœ… Registered"
            elif [ "${DEV_EXIT:-1}" = "2" ]; then
              DEV_STATUS="âš ï¸ Skipped"
            else
              DEV_STATUS="âŒ Failed"
            fi
          else
            DEV_STATUS="âš ï¸ Not configured"
          fi
          
          if [ -n "$BACKEND_URL_PROD" ]; then
            if [ "${PROD_EXIT:-1}" = "0" ]; then
              PROD_STATUS="âœ… Registered"
            elif [ "${PROD_EXIT:-1}" = "2" ]; then
              PROD_STATUS="âš ï¸ Skipped"
            else
              PROD_STATUS="âŒ Failed"
            fi
          else
            PROD_STATUS="âš ï¸ Not configured"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ¤– Android Build & Deploy Summary
          
          ### ðŸ“¦ Build Information
          - **Version Code**: ${{ steps.version.outputs.version_code }}
          - **Version Name**: ${{ steps.version.outputs.version_name }}
          - **Commit**: ${{ steps.version.outputs.commit_short }}
          - **Build Time**: ${{ steps.version.outputs.build_time }}
          - **Workflow Run**: #${{ github.run_number }}
          
          ### âœ… Artifacts Built
          
          #### Release APK
          - **SHA256**: \`${{ steps.apk_metadata.outputs.SHA256 }}\`
          - **Size**: ${{ steps.apk_metadata.outputs.FILE_SIZE }} bytes
          - **Signature**: Verified âœ…
          - **Available**: GitHub Artifacts (90 days)
          
          #### Debug APK (Development Only)
          - **Signature**: Verified âœ…
          - **Available**: GitHub Artifacts (30 days)
          
          #### Release AAB (Google Play)
          - **Available**: GitHub Artifacts (90 days)
          
          ### ðŸš€ Backend Deployment Status
          
          #### Development Backend
          - **Status**: $DEV_STATUS
          EOF
          
          if [ -n "$BACKEND_URL_DEV" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          - **Dashboard**: [$BACKEND_URL_DEV/apk-management]($BACKEND_URL_DEV/apk-management)
          EOF
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          #### Production Backend
          - **Status**: $PROD_STATUS
          EOF
          
          if [ -n "$BACKEND_URL_PROD" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          - **Dashboard**: [$BACKEND_URL_PROD/apk-management]($BACKEND_URL_PROD/apk-management)
          EOF
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ### ðŸ” Security
          - All APKs signed with production keystore
          - Signatures verified with apksigner
          - Release APK registered in APK Management system for fleet deployment
          
          ### ðŸ“¥ Download
          - [Debug APK (30 days retention)](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Release APK (90 days retention)](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Release AAB (90 days retention)](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          
          echo "ðŸ“Š Build summary generated successfully"

      - name: Clean up keystore
        if: always()
        run: |
          if [ -f "${{ github.workspace }}/release.keystore" ]; then
            rm -f "${{ github.workspace }}/release.keystore"
            echo "ðŸ§¹ Keystore cleaned up"
          fi
